## 整体思路

需要总结下每个步骤各自的技巧以及常见题型的递归式

### 定义数据元素的含义

这里就存在一个选择，使用一维数据还是二维数据

- 适用于一维数据的情况
- 适用于二维数据的情况（80%，使用频率较高）

有些题目，数组定义的结果就是题目的结果，有些题目可能数据定义的结果并不是题目最终的答案，需要再处理下。

### 找出元素之间的关系式

稍微难点的题目，关系式不是那么容易找出来的。而且可能关系式，不像下面几种一样，是唯一的，而是根据不同的场景，而是有多种情况的。

```java
dp[i] = dp[i-1] + dp[i-2]
```
```java
dp[i] [j] = dp[i-1] [j] + dp[i] [j-1]
```
```java
dp[i] [j] = min(dp[i-1][j]，dp[i][j-1]) + arr[i][j];
```
```java
dp[i] [j] = min(dp[i-1] [j-1]，dp[i] [j-1]，dp[[i-1] [j]]) + 1
```
```java
dp[i] = max(array[i], dp[i-1]+array[i])
```

```java
当 i < 0,则 dp[j] = dp[j − 1] + 1 ；
当 dp[j - 1] < j - i，则 dp[j] = dp[j − 1] + 1 ；
当 dp[j − 1] ≥ j − i,则 dp[j] = j - i；
```
```java
dp[i]=min(dp[a]×2,dp[b]×3,dp[c]×5)
```
$$
dp[n][j]= 
\sum_{i-1}^6
 dp[n−1][j−i]
$$

$$
dp[n][x]= 
\sum_{i-1}^6
 dp[n−1][x−i]
 \frac 16
$$

$$
dp[i]= 
\max(dp[i-2]+nums[i],dp[i-1])
$$

$$
dp[i]= (i-1)*dp[i-2]+(i-1)*dp[i-1]
$$

$$
dp[i]= dp[i-1]+dp[i-3]
$$

总结下来，基本上分三种

1. 简单模式。可以直接找出找出关系式，且只有一个。
2. 中等模式。存在多个关系式，匹配不同的场景。
3. 困难模式。数学公式推导出来的关系式。

明确一维数组和二位数组适用的场景

- 一维数组。
- 二位数组。

### 找出初始值 

## 适用的场景

- 最多、最少、最大、最小、最高、总共等关键字，一般可以使用动态规划。
- 求按从小到大的顺序的第N个丑数
- 请列出所有可能的 `S` 值及其相应的概率。
- 把 n 个骰子扔在地上，求点数和为 s 的概率。
- 错误装信方式的数量
- 求 N 年后牛的数量
- 范围内元素的总和



## 常见题型

- 斐波那契数列
- 矩阵路径
- 分割整数
- 最长递增子序列
- 最长公共子序列
- 0-1 背包
- 股票交易
- 字符串编辑



## 优化 

